# Generated by https://quicktype.io
#
# To change quicktype's target language, run command:
#
#   "Set quicktype target language"

from enum import Enum
from pydantic import BaseModel, Field, ConfigDict
from typing import Optional, Union, List, Dict, Any

# Types for our APIs to use

TANA_TEXT = "tana-text"
TANA_NODE = "tana-node"

class Props(BaseModel):
  created: int
  name: str = ''
  description: Optional[str] = None
  ownerId: Optional[str] = Field(default=None, alias='_ownerId')
  metaNodeId: Optional[str] = Field(default=None, alias='_metaNodeId')
  docType: Optional[str] = Field(default=None, alias='_docType')
  sourceId: Optional[str] = Field(default=None, alias='_sourceId')
  view: Optional[str] = None
  editMode: Optional[bool] = False
  done: Optional[Union[bool, int, None]] = None


class NodeDump(BaseModel):
  id: str
  props: Props
  touchCounts: Optional[List[int]] = None
  modifiedTs: Optional[List[int]] = None
  children: Optional[List[str]] = None
  associationMap: Optional[Dict[str, str]] = None
  underConstruction: Optional[bool] = None
  inbound_refs: Optional[List[str]] = []
  outbound_refs: Optional[List[str]] = []
  color: Optional[str] = None
  tags: List[str] = []
  content: List[str] = []
  fields:List[dict] = []
  

# config for graph visualization.
# By default, we inlucde all linkages
class Visualizer(BaseModel):
  include_tag_tag_links: bool = True
  include_node_tag_links: bool = True
  include_inline_refs: bool = True
  include_inline_ref_nodes: bool = True
  include_content_nodes: bool = False
  include_tag_schema_links: Optional[bool] = False
  # make this hashable
  model_config = ConfigDict(frozen = True)


class TanaDump(BaseModel):
  formatVersion: int
  docs: List[NodeDump]
  editors: List[List[Union[int, str]]]
  workspaces: Dict[str, str]
  lastTxid: Optional[int] = None
  lastFbKey: Optional[str] = None
  optimisticTransIds: Optional[List[Any]] = None
  currentWorkspaceId: Optional[str] = None

  visualize: Optional[Visualizer] = None


class TanaField(BaseModel):
  field_id: str
  name: str
  value_id: str
  value: str
  #tag_id: str = ''

class TanaTag(BaseModel):
  id: str
  name: str
  description: Optional[str] = None
  color: Optional[str] = None

class TanaContent(BaseModel):
  id: str # the tana node id
  name: str
  description: Optional[str]

class TanaContentElement(BaseModel):
  id: Optional[str] = None
  is_reference: bool = False
  is_field: bool = False
  field_name: str | None = None
  content: str

# A Tana Topic is anything that is tagged. This is the "logical document" of the Tana 
# worksapce for the purpose of our RAG efforts
class TanaTopicNode(TanaContent):
  tags: List[str] = []
  fields: Optional[List[TanaField]]
  # TODO: consider whether we should preserve more node structure here
  content: List[TanaContentElement] = []

# A Tana Content Node is a child of a topic node. We split this out for
# finer grained embedding purposes - and because single topics are too
# large to embed in one go.
# Content Nodes are assumed to be flat text - no fields, no tags.
class TanaContentNode(TanaContent):
  topic_id: str # the parent topic we are part of


class TanaNodeMetadata(BaseModel):
  category: str = TANA_NODE
  title: str
  supertag: Optional[str] = None
  topic_id: Optional[str] = None
  node_id: Optional[str] = None
  text: Optional[str] = None
  hash: int

class GraphLink(BaseModel):
  source: str
  target: str
  reason: str
